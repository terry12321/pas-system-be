let cryptoJS = require('crypto-js')
let moment = require(`moment`);

let rb = {
    qp: undefined,
    cryptoKey: undefined,
    build: function build(data, message, status, log, option) {
        try {
            option = option || {};
            if (option.byPassEncryption) {

            } else {
                if (rb.cryptoKey) {
                    data = cryptoJS.AES.encrypt(JSON.stringify(data), rb.cryptoKey).toString()
                }
            }

            let response =
            {
                status: status || 200,
                message: message || "",
                data: data || {},
                log: log || "",
            }
            if (option.token) {
                response.token = option.token;
            }
            return response;
        } catch (err) {
            return rb.buildError(err);
        }
    },
    buildToken: function buildToken(token, data, message, status, log, option) {
        try {
            option = option || {};
            option.token = token;
            return rb.build(data, message, status, log, option);
        } catch (err) {
            return rb.buildError(err);
        }
    },
    buildJson: (json, message, status, log, option) => {
        try {
            option = option || {};
            if (option.byPassEncryption) {

            } else {
                if (rb.cryptoKey) {
                    json = cryptoJS.AES.encrypt(json, rb.cryptoKey).toString()
                }
            }
            let response =
            {
                status: status || 200,
                message: message || "",
                data: json || {},
                log: log || ""
            }
            return response;
        } catch (err) {
            return rb.buildError(err);
        }
    },
    buildError: function buildError(message, status, data, log, accept200) {
        let response = "";
        if (message.status == 200) {
            if (accept200) {

            } else {
                delete message.status;
            }
        }
        if (message instanceof Error) {
            response =
            {
                status: message.status || 500,
                message: message.message || "",
                data: data || {}
            }
        } else {
            response =
            {
                status: status || 500,
                message: message || "",
                data: data || {},
                log: log || ""
            }
        }
        return response;
    },
    buildErrorObject: function buildError(error) {
        console.log(`Deprecated!`);
        let response =
        {
            status: error.status || 500,
            message: error.message || "",
            data: data || {}
        }
        return response;
    },
    presetCryptoKey: function preset(key) {
        rb.cryptoKey = key;
    },
    /**
     * You must await thie method
     * otherParams is optional and designed as an object
     */
    buildTable: async (body, searchQueryWithColon, allQueryWithColon, otherParams, buildOption, dbConfig) => {
        if (!rb.qp)
            rb.qp = require('flexqp');
        let qp = rb.qp;
        let con;
        otherParams = otherParams || {};
        try {
            if (!searchQueryWithColon.includes(`SQL_CALC_FOUND_ROWS`)) {
                searchQueryWithColon = searchQueryWithColon.replace(/select/i, 'select SQL_CALC_FOUND_ROWS')
            }
            if (!allQueryWithColon.includes(`SQL_CALC_FOUND_ROWS`)) {
                allQueryWithColon = allQueryWithColon.replace(/select/i, 'select SQL_CALC_FOUND_ROWS')
            }
            if (body.search.value) {
                if (!searchQueryWithColon.includes(`:search`)) {
                    let err = new Error(`:search is required in search query`);
                    console.log(err);
                    throw err;
                }
            }

            let searchValue = body.search.value == undefined ? null : body.search.value;
            let rows = Number(body.length || 20);
            let minValue = Number(body.start);
            let columnName = body.columns[Number(body.order[0].column)].data;
            let order = body.order[0].dir; // desc or asc
            let sorting = `\`${columnName}\` ${order} `;
            let limit;
            rows === -1 ? limit = '' : limit = 'limit :minValue, :rows';
            let query = ``; //final query
            let param = {};
            con = await qp.connectWithTbegin(dbConfig);
            if (searchValue) {
                query = `${searchQueryWithColon} order by ${sorting}${limit}`;
                param = { search: searchValue, minValue: minValue, rows: rows };
            } else {
                query = `${allQueryWithColon} order by ${sorting}${limit}`;
                param = { search: searchValue, minValue: minValue, rows: rows }
            }
            let option = {
                sql: query, typeCast: function (field, next) {
                    if (field.type == 'JSON') {
                        return JSON.parse(field.string());
                    }
                    if (field.type == 'TIMESTAMP' || field.type == 'DATETIME') {
                        let str = field.string();
                        if (str != null)
                            return moment(str).format('YYYY-MM-DD HH:mm:ss');
                        else
                            return str;
                    }

                    if (field.type == 'DATE') {
                        let str = field.string();
                        if (str != null)
                            return moment(str).format('YYYY-MM-DD');
                        else
                            return str;
                    }
                    return next();
                }
            };
            param = Object.assign(otherParams, param)
            let result = await qp.execute(query, param, con);
            let count = await qp.execute(`select found_rows() as totalCount;`, [], con);
            count = count[0];
            let data = { draw: body.draw, recordsTotal: count.totalCount, recordsFiltered: count.totalCount, data: result };
            await qp.commitAndCloseConnection(con);
            return rb.build(data, `Success!`, null, null, buildOption);
        } catch (err) {
            await qp.rollbackAndCloseConnection(con);
            console.log(err);
            throw err;
        }
    },

    buildCustomTable: (draw, recordsTotal, recordsFiltered, result, buildOption) => {
        let data = { draw: draw, recordsTotal: recordsTotal, recordsFiltered: recordsFiltered, data: result };
        return rb.build(data, `Success!`, null, null, buildOption);
    },
    setQpDriver: (qp) => {
        rb.qp = qp || require('flexqp');
    },

    renderTable: (daoArr) => {
        let err = new Error(`DAO keys do not match`);
        err.status = 409;
        let colSet = new Set(Object.keys(daoArr[0]));
        for (let dao of daoArr) {
            let setSize = colSet.size;
            let keys = Object.keys(dao);
            if (setSize !== keys.length) throw (err);
            keys.forEach(k => colSet.add(k));
            if (colSet.size !== setSize) throw (err);
        }
        let cols = [...colSet.values()];
        let table = buildHtmlTable(daoArr, cols);
        return rb.build(table, `Success!`);
    }
}

function buildHtmlTable(data, colArr) {
    let ths = ``;
    for (let col of colArr) {
        ths += `                <th>${col}</th>
        `
    }
    let header = `
        <thead>
            <tr>
                ${ths}
            </tr>
        </thead>
    `

    let body = ``;
    for (let d of data) {
        let tds = ``
        body += `<tr>`
        for (let col of colArr) {
            tds += `<td>${d[col]}</td>`
        }
        body += tds;
        body += `</tr>`
    }
    let table = `
        <table class="table text-center table-striped">
            ${header}
            <tbody>
                ${body}
            </tbody>
        </table>
    `;

    return table;
}

module.exports = rb;